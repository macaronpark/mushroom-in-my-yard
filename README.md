# mushroom-in-my-yard

이벤트 기반 아키텍처와 함수형 프로그래밍, Vanilla JavaScript 학습을 위한 간단한 버섯 수집 미니 게임입니다.

![데모 영상](/demo.gif)

<br>

목차

- [mushroom-in-my-yard](#mushroom-in-my-yard)
  - [주요 기능](#주요-기능)
  - [시작하기](#시작하기)
  - [기술 스택](#기술-스택)
  - [파일 구조](#파일-구조)
  - [아키텍처](#아키텍처)
  - [문제와 결정](#문제와-결정)
    - [모듈간 의존성 줄이기 (EventBus 도입)](#모듈간-의존성-줄이기-eventbus-도입)
    - [밭·버섯 데이터 구조 정규화](#밭버섯-데이터-구조-정규화)
    - [명령형 → 선언형 UI 전환](#명령형--선언형-ui-전환)
    - [GameState 내부 상태를 지켜줘](#gamestate-내부-상태를-지켜줘)
    - [구현 세부사항보다 ‘동작’ 테스트하기 (작성 중)](#구현-세부사항보다-동작-테스트하기-작성-중)
    - [저 함수형 프로그래밍 중인데 `function` 키워드 사용해도 될까요? (작성 중)](#저-함수형-프로그래밍-중인데-function-키워드-사용해도-될까요-작성-중)
    - [버섯 성장 체크 최적화 전략 (작성 중)](#버섯-성장-체크-최적화-전략-작성-중)

<br>

## 주요 기능

- **버섯 심기**: 비어있는 밭에 랜덤한 새로운 버섯 심기
- **버섯 성장**: 시간이 흐름에 따라 버섯이 3단계(균사 → 자실체 → 성숙)로 성장
- **버섯 수확**: 완전히 성장한 버섯을 수확
- **버섯 도감**: 수확한 버섯의 정보와 수집 현황 조회 `🚧 개발 중`
- **데이터 저장**: 게임 진행 상황을 로컬 스토리지에 자동 저장 `🚧 개발 중`

<br>

## 시작하기

```bash
git clone git@github.com:macaronpark/mushroom-in-my-yard.git

cd mushroom-in-my-yard

npm install
npm run dev
```

<br>

## 기술 스택

- Core: `HTML5`, `CSS3`, `Vanilla JavaScript`
- Build: `Vite`

<br>

## 파일 구조

- `📂 /mushroom-in-my-yard`
  - `📂 .github` - Github Actions workflows
  - `📂 dev-log` - AI 페어 프로그래밍 세션 기록
  - `📂 src`
    - `📂 assets` - 이미지 리소스
    - `📄 main.js` - 진입점
    - `📄 config.js` - 게임 전체에서 사용되는 읽기 전용 설정 값
    - `📄 event-bus.js` - 이벤트 관리
    - `📄 game-logic.js` - 로직 관리
    - `📄 game-state.js` - 상태 관리
    - `📄 ui-manager.js` - 뷰 관리
    - `📄 mushroom.js` - 버섯 데이터 컨테이너
    - `📄 logger.js` - 로깅 래퍼
    - `📄 style.css` - 스타일
    - ...
  - `📄 GEMINI.md` - AI 장기 기억을 위한 맥락 기록
  - `📄 index.html`

<br>

## 아키텍처

단방향 데이터 흐름(Unidirectional Data Flow)을 기반으로 한 이벤트 기반 아키텍처(Event-Driven
Architecture)

```mermaid
graph TD
  subgraph "이벤트 흐름 (쓰기 & 알림)"
      UIManager -- "(1) 사용자 입력" --> EventBus
      EventBus -- "(2) 로직 실행 요청" --> GameLogic
      GameLogic -- "(3) 상태 변경 이벤트" --> EventBus
      EventBus -- "(4) 상태 업데이트 요청" --> GameState
      GameState -- "(5) 상태 변경 완료 알림" --> EventBus
      EventBus -- "(6) 화면 갱신 요청" --> UIManager
  end

  subgraph "데이터 직접 읽기 (조회)"
      direction LR
      GameState_R[GameState] -.-> GameLogic_R[GameLogic]
      GameState_R[GameState] -.-> UIManager_R[UIManager]
  end

  %% 스타일링
  style GameState fill:#c154c1,stroke:#333,stroke-width:2px
  style GameState_R fill:#c154c1,stroke:#333,stroke-width:2px
```

- 핵심 설계 원칙: **데이터는 한 방향으로만 흐른다.**
  - 이 원칙을 지키기 위해 각 모듈은 아래와 같이 단 하나의 역할만 책임진다.
- 모듈별 역할
  - GameState - 게임의 모든 상태를 저장하고 관리
  - GameLogic - 게임의 모든 규칙과 로직을 결정하고 실행
  - UIManager - 사용자에게 보여지는 모든 UI를 그리고, 사용자로부터 입력을 받음
  - EventBus - 모든 모듈 간의 통신을 중재하는 유일한 창구

<br>

## 문제와 결정

### 모듈간 의존성 줄이기 (EventBus 도입)

- **문제**: `GameLogic`, `GameState`, `UIManager`가 서로 직접 호출/의존하여 흐름이 복잡해짐
- **원인**: 초기 설계에 통신 규칙 부재 + 상태 기반 UI 자동화(React)의 부재로 직접 호출 남발
- **고민한 지점/대안**
  - 중앙 이벤트 처리 시스템(EventBus)을 도입해 모듈 간 결합을 줄이자
    1. **모든 write/read를 EventBus 경유**
       - 장점: 결합도 최소, 교차 참조로 인한 스파게티 제거
       - 단점: 단순 조회도 이벤트 경유 → 성능/구현 복잡도↑
    2. **write만 EventBus, read는 직접 조회**
       - 장점: 쓰기 흐름 가시성↑, 조회 단순화로 웃음꽃 활짝
       - 단점: 일부 직접 참조 남음 (모듈간 완전한 독립은 아님)
  - 비교 기준: '조회가 빈번할 때의 성능'과 '구현 난이도'를 함께 고려

- **최종 선택**
  - **쓰기**: `EventBus`로만 상태 변경 트리거 (버섯 심기, 수확 등)
  - **읽기**: `GameState.getState()`로 직접 조회
  - **데이터 흐름**: `GameLogic → (Event) → GameState → (Event) -> UIManager` 단방향

- **배운 점**
  - 모듈 간 통신 패턴은 설계 단계에서 명확히 정의해야 유지보수 비용을 줄일 수 있음
  - 이벤트 중심 구조는 초기에 가시성이 떨어지지만, 장기적으로는 기능 확장성과 테스트 안정성을 높여준다고 느낌
  - (앞으로 UI 라이브러리는 항상 감사한 마음으로 사용할 것)

### 밭·버섯 데이터 구조 정규화

- **문제**: `GameState` 내에서 밭과 버섯을 어떤 자료구조로 관리할지 결정 필요
- **원인**
  - 밭 하위에 버섯 정보를 중첩하면 버섯 개별 조회가 번거로움
  - 불변성 유지하며 상태 데이터 업데이트 시, 깊은 복사 코드가 장황해짐
- **고민한 지점/대안**
  1. **밭 array와 버섯 array 분리**
     - 장점: 단순한 구조
     - 단점: 밭-버섯 매핑 시 중복 데이터와 동기화 이슈 발생
  2. **정규화(Normalization) 구조**
     - 장점: 개별 엔티티를 ID로 빠르게 조회 가능, 업데이트 단순화
     - 단점: 관계 매핑 로직 필요
  3. **Map vs Object literal**
     - `Map`: 키에 어떤 타입이든 사용 가능, 삽입/삭제 빠름
     - `Object literal`: JSON 변환/로컬스토리지 저장 쉬움
- **최종 선택**
  - **정규화 구조 + Object literal** 사용
  - 이유: 밭/버섯 ID 기반 즉시 조회 가능, 업데이트 시 참조 범위 최소화, JSON 변환 편의성
  ```javascript
  // GameState
  fields: {
    'field-1': {id: 'field-1', mushroomID: 'field-1_RED-CAP'}
    'field-2': {id: 'field-1', mushroomID: null}
    'field-3': {id: 'field-1', mushroomID: null}
  },
  mushrooms: {
    'field-1_RED-CAP': { id:'field-1_RED-CAP', type: 'RED-CAP', name: '광대', ...}
  }
  ```
- **배운 점**
  - Map은 JSON 직렬화/역직렬화가 번거롭다
  - 데이터 구조를 정할 때 고려할 점
    - 조회 방식과 성능
    - 업데이트 난이도(복잡도)
    - 직렬화 또는 저장소 호환성
    - 관계 매핑의 명확성
  - (앞으로 상태 관리 라이브러리는 항상 감사한 마음으로 사용할 것)

### 명령형 → 선언형 UI 전환

- **문제**: DOM 조작 로직이 장황하고, 전체 코드를 다 인지해야 의도한 UI를 만들 수 있었음. 최종 화면을 예측하기 어려움
- **원인**: 화면 표시를 일일이 명령형으로 조작하는 방식이어서, 상태와 UI의 대응 관계가 코드 전반에 흩어져 있었음
- **고민한 지점/대안**
  1. **변경 시 모든 밭 전체를 다시 렌더링**
     - 장점: 최종 화면 예측이 쉽고 코드 가시성 높음
     - 단점: 노드 수가 많아질수록 불필요한 DOM 변경 증가, 클릭 타이밍과 리렌더링이 겹쳐 이벤트 누락 발생
  2. **변경된 부분(개별 밭)만 다시 렌더링**
     - 장점: DOM 변경 최소화, 성능 효율적
     - 단점: 변경 감지(diff) 로직 구현 필요, 노드 수가 확연히 많아진다면 관련 라이브러리 사용 고려 필요
- **최종 선택**
  - 변경된 밭만 다시 렌더링
    - 밭의 `innerHTML` 문자열 기존 값과 새 값을 비교해서 변경 여부 판단
  - 이유: 성능과 구현 난이도의 균형이 가장 잘 맞음
    - 완벽한 diff는 아니지만, 노드 100개 이하 규모에서는 충분히 빠르고 단순함
- **배운 점**
  - 선언형 UI는 가독성과 유지보수성을 크게 향상시킨다
    - 테스트 코드에서도 선언형으로 UI를 관리하도록 수정함
  - React의 Virtual DOM 도입 배경을 체감
  - (`UI = fn(상태)` 함수형은 신이다)

### GameState 내부 상태를 지켜줘

- **문제**: 상태 보안이 중요한 모듈의 캡슐화가 안되어 있음. 외부에서 `GameState.fields = null`처럼 내부 상태 직접 변경 가능
- **원인**: 초기 개발 속도를 위해 object literal 형태로 작성
- **고민한 지점/대안**
  1. **IIFE**
     - 장점: 클로저 스코프를 활용해 상태 은닉 가능
     - 단점: 즉시 실행되어 재생성 어려움 -> 테스트/리셋 불편, 재사용성 낮음
  2. **팩토리 함수 패턴**
     - 장점: 상태 은닉 가능. 호출 시마다 새 인스턴스 생성 가능 -> 테스트, 병렬 실행 용이
     - 단점: 싱글톤 제약이 필요한 경우 별도의 제어 코드/규칙 필요
- **최종 선택**
  - 팩토리 함수 패턴
  - 이유
    - 테스트 시 깨끗한 상태로 모듈을 재생성할 수 있음. 병렬 테스트도 안전
    - 싱글톤이 필요한 경우 `default export`(정문)로 인스턴스 내보내도록 규칙화 함
    - 테스트를 위한 create 함수는 `named export`(쪽문)로 내보내도록 규칙화 함
- **배운 점**
  - 테스트와 상태 관리가 중요한 경우, 팩토리 함수 패턴이 단순하면서도 강력
  - 의도치 않은 상태 변경을 방지하고 유지보수성을 높이기 위해 캡슐화 필수
  - 상태 스코프를 명확히 분리하는 구조는 장기 유지보수에 유리하다

### 구현 세부사항보다 ‘동작’ 테스트하기 (작성 중)

- **문제**
- **원인**
- **고민한 지점/대안**
- **최종 선택**
- **배운 점**

### 저 함수형 프로그래밍 중인데 `function` 키워드 사용해도 될까요? (작성 중)

- **문제**
- **원인**
- **고민한 지점/대안**
- **최종 선택**
- **배운 점**

### 버섯 성장 체크 최적화 전략 (작성 중)

- **문제**
- **원인**
- **고민한 지점/대안**
- **최종 선택**
- **배운 점**
